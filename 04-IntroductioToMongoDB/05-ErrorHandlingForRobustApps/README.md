# Lesson (unit) 6: Crafting Robust Applications: Error Handling in Node.js and Express.js
Astounding work reaching this point in the course! Learning error handling is 
like navigating through an asteroid beltâ€”tricky but thrilling. Buckle up for 
some coding adventure! ðŸš€

## Lesson Overview
In this session, we're delving into error handling within `Node.js` and `Express.js`. As a robot needs instructions for instances when an object 
cannot be found, our code similarly requires mechanisms for handling errors.

## Introduction to the Try/Catch Block
Error handling is a procedure that detects and manages errors during program 
execution. Unhandled errors, generated by Syntax Errors (breaches of 
JavaScript rules), and Runtime Errors (exceptions during execution), can 
disrupt programs â€” akin to a robot attempting to find a non-existent object.

The `try` statement examines a block of code for errors. Any existing errors 
are "caught" by the `catch` block, thus providing error management.

```JavaScript
try {
  // Attempts to print 'num'
  console.log(num);
} catch (err) {
  // If an error occurs (e.g., `num` wasn't defined), it's caught, and an error message is printed
  console.log(err.message);
}
```
In this piece of code, instead of letting the program crash (due to the issue 
that `num` is not defined), we "catch" the error and handle it gracefully.

## Error Responses in API
Effective error handling enhances user experience by utilizing appropriate 
HTTP status codes (e.g., `HTTP 200` signifies success, `HTTP 404` denotes a 
resource not found, `HTTP 500` denotes an internal server error) within the API.

```JavaScript
// Endpoint for retrieving user data by ID
app.get('/api/user/:id', (req, res) => {
  try {
    const user = getUserById(req.params.id);
    if (!user) {
      // If the user was not found, return status 404
      res.status(404).json({message: "User not found"});
      return;
    }
    res.json(user);
  } catch (err) {
    // If an error occurs, a response with status code 500 is sent
    res.status(500).json({ error: "Server error" });
  }
});
```
In this context, we use `try/catch` for handling server-side exceptions, and `catch` dispatches an HTTP status code 500 (Internal Server Error) for server errors.

## Error Handling in a Full-Stack Application
In a full-stack application, both client and server errors require attention.

For the server, consider the following:

```JavaScript
// API endpoint that attempts to update a user's details
app.put('/api/user/:id', (req, res) => {
  try {
    const user = updateUser(req.params.id, req.body);
    // rest of the code
  } catch (err) {
    // If an error occurs, an error response is sent
    res.status(500).json({ error: 'Failed to update user' });
  }
});
```
On the client side (React with Axios), the `catch` block manages errors 
during the GET request.

```JavaScript
import React, { useEffect } from 'react';
import axios from 'axios';

function App() {
  useEffect(() => {
    // This function will be triggered after the component is mounted
    axios.get('/api/user/123')
      .then(res => {
        // Handle success
      }).catch(err => {
        // Error during GET request is handled here
        console.error(err.message);
      });
  }, []);
 
  // Rest of the functional component code

  return (
    // Your JSX here
  );
}

export default App;
```

## Lesson Summary
Today, we have covered error handling, `try/catch` blocks, error handling in 
APIs, and a full-stack application. By avoiding application crashes and 
providing valuable feedback, proper error handling proves beneficial. Prepare 
for forthcoming practice tasks, where your learning is enhanced by practical 
application. Remember, to err is human; to handle is divine!

```
``